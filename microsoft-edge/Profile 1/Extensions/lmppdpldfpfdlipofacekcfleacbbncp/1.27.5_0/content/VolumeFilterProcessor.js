/*! For license information please see VolumeFilterProcessor.js.LICENSE.txt */
(()=>{"use strict";class t extends AudioWorkletProcessor{constructor(...t){super(...t),this.keepAlive=!0,this.port.onmessage=t=>{"destroy"===t.data&&(this.keepAlive=!1)}}}function e(t){return Math.round(t*sampleRate)}class s extends Float32Array{constructor(t){super(t),this._lastSampleI=t-1}push(t){++this._lastSampleI,this._lastSampleI>=this.length&&(this._lastSampleI=0),this[this._lastSampleI]=t}getReverse(t){return this[(this._lastSampleI-t+this.length)%this.length]}}registerProcessor("VolumeFilter",class extends t{constructor(t,...r){super(t,...r),this._currWindowSquaresSum=0,this._options={maxChannels:32,maxSmoothingWindowLength:t.parameterData.smoothingWindowLength,...t.processorOptions};const i=e(this._options.maxSmoothingWindowLength);this._sampleSquaresRingBuffer=new s(i)}static get parameterDescriptors(){return[{name:"smoothingWindowLength",defaultValue:.02,minValue:0,automationRate:"k-rate"}]}process(t,s,r){const i=e(r.smoothingWindowLength[0]),n=t[0];if(0===n.length)return this.keepAlive;const o=s[0][0],a=n.length,h=n[0].length;for(let t=0;t<h;t++){let e=0;for(let s=0;s<a;s++)e+=n[s][t]**2;const s=e/a,r=this._sampleSquaresRingBuffer.getReverse(i-1);this._currWindowSquaresSum-=r,this._currWindowSquaresSum+=s,this._currWindowSquaresSum=Math.max(this._currWindowSquaresSum,0),this._sampleSquaresRingBuffer.push(s);const h=Math.sqrt(this._currWindowSquaresSum/i);o[t]=h}return this.keepAlive}})})();